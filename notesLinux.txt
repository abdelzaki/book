
- export command ?


##############################################################################################################################################################
################################################################ Introduction   ##############################################################################	
##############################################################################################################################################################

- linux firmware used to understand the lower leverl hardware function to write interface to peripheral : GPIO, Timers, CAN, UART










###########################################################################################################################################


- Asemble:
	- "call" function in Asemble : put the next address(address after the function call ) to the the stack and move to the function which should be called.
	- %eax -> it means register 
	- compiler decide which data goes to register or to stack.
	- Register -> compiler,  Cache -> HW decided,  Memory -> operationg system,  Storage -> operating system

- Dual-Mode:
	- there is a bit in in the processor (HW) which we can set/reset it to switch between User / kernel Mode
	- instruction change the mode to kernel and another to change to user mode
	
- System call: 
	- should be supported by the hardware
	- save numbe of system call in register
	- call int with the number of the system call to excute system call
	
- interrupt:
	- Hardware moves to Kernel stack
	- if system call inside the kernel stack, the Stack would grow no new stack should be created

- Ring buffer:
	- modula arithmetic
	 
- Microkernel: 
	- multiable proccess to excute the code
	
- monolithic:
	- the kernel is one proccess
	
- kernel address:
	- 32 bits is always 4 GBs
	- kernel is always the first 1 GB of the RAM
	
- scheudler:
	- maxium CPU utilization
	- first come first service Process policy
	- burst time -> how long the process will excute untill it blocks
	- Round Robin :
		- quantum -> how long is process is allowed to run 
		- if quantum is infinity then we have first run first service
		- if quantum is zero not then we wont excute any thing 
		- 
- NAND:
	- allow random access
	- write -> can only change 1 to 0
	- to change the bit to one u have to erase block 
	- the SSD has flash translation layer(FTL) which achieve wear leaving
	- it has OOB (out of band) area to store error detection 
	
- NOR:
	- code can be excuted from it
	- it is expensive

- malloc:
	- sbrk -> to create heap page
	- malloc is implemenit in library not in the kernel
	- 	
- stack:
	- in linux stack is expandable

- heap:
	-  	
- JFFS2:
	- it applied 3 lists empty, full, dirty -> to avoid copy and paste data which not needed to copy
	
- Files:
	- file is a string of bytes
	
- inode:
	- it identify a file, it has alot of data about the file 


- task_struct:
	- it represents a process
	
- pid:
	- it identify a process

##############################################################################################################################################################
################################################################ Embedded Linux ##############################################################################	
##############################################################################################################################################################

- Components:
	- Toolchain -> to compile linux
	- Bootloader -> the program which will load the kernel to memory, initialize memory, and load kernel to it, pass command line to the kernel 
	- Kernel -> it manages the resources, lowest level software running on the system 
	- system call interface -> inteface between application and kernel. it is called through C- Runtime library
	- C-Runtime
	- shared library
	- Root file system -> contains what the linux will run when it started to run
	

- Toolchain:
	- set of tools that compilesource code into executable
	- Components are : compiler, linker, run time libraries


- under arch/<architecture>/machine-omap 
	- there would be the code used to work with this board

##############################################################################################################################################################
##################################################################     I/O      ##############################################################################	
##############################################################################################################################################################

- all memeory access should be through mmu unit
- I/O is mapped in two ways:
	- regoin in process is reserved fpr mapping the I/O called "memeory mapped IO MMIO"
	- using a special instruction to access the I/O called "port mapped IO" PIO
	
- u need to ask the permission from the OS to get access the memory region u want to access

- ioremap:
	- map the address to a process address space 
	- it is ARCH specific header
	- it takes physical address as a parameter
	- __iomem -> compiler attribute to tell it is a IO 
	
- in order to work on IO memoy region two steps are required
	-> ask permission "requestrequest_mem_region"
	-> map the IO to VAS "ioremap"
	-> write to it through using specifi API "ioread, iowrite"

- the another way is accessing the port by a special instructions:
	- inb,outb
	
##############################################################################################################################################################
##################################################################      I2C     ##############################################################################	
##############################################################################################################################################################

- every device should have address
- it is 2 line communications
- the line has 7 bits address
- master talks to 1 address at a time
- driver is rep

##############################################################################################################################################################
##################################################################      GPIO     #############################################################################	
##############################################################################################################################################################

- GPIO subsystem consist of 3 layers :
	- core -> HW independent comes from Linux itself, which is the middle layer between producer and consumer
	- producer -> it is HW dependent for each SOC there should be producer which knows how to handle SOC and it should register itself 
					to the core
	- consumer -> it communicate with the core to contril GPIO
	
- dt:
	- led-gpios = <&gpio 15 pull_up>
		led -> it is the function
		gpio -> it is the phandle
	
##############################################################################################################################################################
################################################################### Boot process #############################################################################	
##############################################################################################################################################################

- Bootloader:
	- initializes memeory
	- load kernel and RFS to RAM and create excutation enviroment
	- bootloader should pass data structure which descripe HW and pass pointer to kernel command line

 - POR:
	- Hardware forces the arm processor to start execuation from boot ROM
	- in some boards depending on Pin state Rom Code scan the content of different media storage (Flash, SD card) it will put contents of data in SDRAM
	
1th Stage:
	- Rom code load secondary program loader (SPL) from Flash / USB / internet to SRAM

2th Stage:
	- load Uboot from flash / USB /internet to DRAM
	
U-boot:
	- bootm address_of_kernel address_of_ramdisk address_of_dtb
	- pass memory address of kernel and device tree
	- kernel will start and will call init process -> busybox init or systemV or system D

Image:
	- is vmlinux converted as binary format
	
zImage:
	- compressed Image 

uImage:
	- zImage + 64-byte U-Boot header

bootargs:
	- is a way to send data to the kernel 
	- u can tell the type of the file system and the serial port which the kernel is going to use to send debug message
	- it is uboot standard enviromental variable

- uEnv:
	- printenv:
		- print all the enviromental variables
		- printenv soc -> to show the value of a variable

	- setenv serverip 192.168.0.1 -> used for tftp  
		- to store value in a variable

	- run commandname:
		- to execute command

	- load:
		- to load a file from file system to RAM

	- boot:
		- will execute run bootcmd 

	- bootm: bootm address_of_linux - address_of_dtb
		- boot from memeory

	-loadx:
		- download via xmodem

- uBoot:
	- it is supported by DNX
	- under board u will find in this folder

- toolchain:
	- download toolchain
	- add path in /home/user/.baschrc 
	- source /home/user/.bashrc
	- apply defconfig tp generate .config
	- apply menuconfig to edit .config
	- apply make to build uboot

	
##############################################################################################################################################################
################################################################### RFS #############################################################################	
##############################################################################################################################################################	

initramfs:
	- also known as Ramdisks 
	- file system image which is in RAM by bootloader
	- it is compressed cpio which is a compressed archive 
	- 
	
Disk image:
	- copy of Root file system which is ready to be copied in mass stotage device 
	
##############################################################################################################################################################
################################################################### Init Process #############################################################################	
##############################################################################################################################################################	

/etc/inittab: 
	- Configuration file to decide where to find the init process
	- ::sysinit:/etc/init,d/rcS -> where to run the first script
	- ::rspawn:/sbin/syslogd -n -> keep it running

##############################################################################################################################################################
################################################################### Memory ###################################################################################	
##############################################################################################################################################################

- Logical address:
	- memory inside the process.
	- it is divided to page and offset inside the page
	
- Linear address / Virtual address :
	- 4 GB Ram address 0X00000000 -> 0XFFFFFFFF
	- the address after MMU calculation

---> Page frame in Linux is 2^12 = 4096 = 4 KB


- physical address:
	- memory cell in memory chips
	
- Kernel memeory address:
	- 896 MB is the kernel
	- 128 MB is high memory mapping
	- at the end we get 1 GB kernel 
	
- MMU:
	- Logical address -> /Segemenataion Unit/ -> Linear address -> /Paging unit/ -> physical address 	
	
- Layout of Memory:
	- kernel doesnot start from 0X0 address because that is stored for BIOS routine in Laptop 

- mem_map:
	- array of page descriptors of type page
	- the last 128 MB of high memory is mapped tp high-memory page frame

- RAM: memory address
	- starts from 0X00100000--0
	- 

- IO Ports:
	- mapped to another Memory address
	- it uses another bus rather than the memory address
	- it is mapped to RAM to make it easier to generate address
	

---> kernel must keep tack of the status of each page frame

- page:
	- it is page descriptor
	- stored in mem_map array
	-  memory is split in Page frame

- Block:
	- process is split in blocks

- process page table:
	- every process has this table
	- it is stored in the kernel space
	- it map block to page frame
	
- page table:
	- it could be 2 level dir,table,offst so we dont need to have contigues memory 

- process:
	- it is a program in excutation
	- every process has PCB (process control block)
	- kernel stack for the process -> it is used to store the context of the process when system call happens
	- page table which map physical memory to virtual memory

- page allocar:
	- array of double linked list which points to a free page frame with size which is 2^order of the array
	

- buddy_allocator:
	- Bit map + buudy allocator
	
	
- slap allocator:
	- it depend on the idea that the kernel uses often  the same area object 
	- allocate a according to a specific object
	
- process get new memory:
	- new process is created
	- process keeps growing until the stack is not enough
	- malloc 

- VAS: 
	- virtual address space
	- divivded to homogenous segement -> text, data, OSS , stack, heap, library
	- thread share every thing in the VAS except stack
	- 

- Thread:
	- kernel schedulable entity (KSE)
	- every thread maps to structure task_structure
	- every thread has user stack and kernel stack
	- kernel stack are fixed in size 2 pages
	- 

---> procces descriptor has a field which points to the address space of the process(memory descriptor)

		##############################################################################################################################################################
		###################################################################   MTD   ##################################################################################
		##############################################################################################################################################################

- MTD:
	- memory technology device
	- it can handle NOR and NAND
	- the kernek knows abouth the partition through Device tree or Board support package
	- MTD with major number 90 to handle char /dev/mtd0 or /dev/mtd2 read and write 
	- mtd with major number 31 to handle block deice /dev/mtdblock0 /dev/mtdblock1
	- flash should always be erase before writting in it
	- static struct mtd_partition mlc3250_nand_partition[] = { -> it is the way to partition Nand device

		##############################################################################################################################################################
		################################################################### Char Driver ##############################################################################
		##############################################################################################################################################################	

- device model:
	- represent devices in an unified way
	- it was first implemented from 2.6 devie tree from 3.7
	
- device:
	- virtual or physical object attached to bus
	- it is represent as struct device

- driver:
	- software entity which can handle a certain device
	- it is represented as struct device_driver

- bus:
	- deivce which can server as an attachment point of serveral devices
	- it is represented as struct bus_type
	

- char device exposed functions and data to user space via /dev
- the driver lives in kernek space

- device number:
	- it consists of MAJOR and MONIR number
	- it is important for VFS so it can connect the driver in Kernel space with the devic in user space
	- driver should register it self to VFS using cdev_add()

- char dev is represented using the followin data structure
	struct cdev{kobject, owner, file_operation, dev_t-> major / minor }

- to create a char device u need to regiser it 
	-> register_chrdev_region -> if u know in advance the dev_t. it will occupy the driver number
	-> alloc_chrdev_region -> to allocate device and let the kernel decide which number will be given to the char driver, it will create 
		deivce under /proc/devices
	-> create class under /sys/class/
	-> create device under /dev -> it represent device not driver as it has minor number and it is created using "mknod" or using device create
	
- file_operation:
	-> open bind the inode with filep because all other file operations work on file data structure not on inode data structure
	
- open call:
	- initialize the device
	- check open permission
	-  identify the file by minor number
	- prepare private data
	- u can get the dev_t number from inode which is argument in the open call, from device number u can get minor number to decide
		which device is opened and provide the data to file private data which is going to be passed to read,write system call
	
- Kernel API:
	- alloc_chrdev_region() -> it will create deive number	
		alloc_chrdev_region(dev_t *dev, baseminor, count, *name)
			- *dev -> it is output 
			- *name -> that is not the name of the device
		 	
	- cdev_init / cdev_add() -> register char device in VFS	
		- cdev_init(struct cdev *cdev,struct file_operation *fops)
		- it will assign file operation in cdev with the given fops 
	
		- cdev_add(struct cdev *p, dev_t dev, unsiged count):
		- it will connect file operation with device number 
		
	
	- class_create() / device_create() -> create device file
		class_create -> create directory in /sys/class/< class_name >
		device_create -> create subdirectory in /sys/class/< class_name > / dev-> which has major and minor  

	- MKDEV:
		- it will creat dev_t variable 
			
		################################################################################################################################################
		################################################################### Platform_driver ############################################################	
		################################################################################################################################################

- it represents a driver and device which is not a part of the conventioal drivers such as I2C, SPI, 

- all non discoverable bus called platform device. 

- u give information about the hardware via board file, load dynamically or device tree

- in order to handle plat_form u need to register the drivers which is a data strucure which contains name, probe, remove

- probe is called when matches happen between plat_form device and plat_form drivers
	it could be a single name matching mechanism or id_table matching mechanism 
	id_table matching mechanism has driver_data which will represent which device is detected

- to represent a plat_form_driver the following data structure should be used "struct platform_driver ":
static struct platform_driver mypdrv = {
	.probe = my_pdrv_probe,
	.remove = my_pdrv_remove,
	.driver = {
		.name = "my_platform_driver",
		.owner = THIS_MODULE,},};
		
- platform_device is represented using platform_device struct:
	struct platform_device {
		const char *name;
		u32 id;
		struct device dev;
		u32 num_resources;
		struct resource *resource;
		};
- when u regiser device as platform device it will be shown in /sys/devices/platform
		
- platform_driver regiser itself to platfrom_bus using platform_driver_register()
		
- resource is what represent the device from the hardware point of view "IO, Memory, IRQ"
	resource{start, stop, name, flag}
	
		############################################################################################################################################
		################################################################### Device tree ############################################################	
		############################################################################################################################################	

- device tree: 
	- is enabled by setting CONFIG_OF to y 
	- collection of device node 
	- it should have a root node
	- it exchanges data between hardware and OS
	-  it describe the hardware of the device
	
- node:
	- it express itself using properities
	- any node can have subnode 
	
- DTS -> it is the source file text file

- DTB -> the compiled source

- dtsi -> header file which represent the SOC level 

- reference:
	- & is used to reference a node in device tree
	
- #size-cells:
	- how many 32-bits represent the size-cells

- #address-cells:
	- how many 32-bits represent address
	
- Properities:
	- it is a key value pair 
	- it is standard names and there is standard to use non standard name (custom proerities)
	- compatible:
		- it is a string list
		- client programm "linux" it is list from the most specific to the most general
		- it is used for driver selections 
		- manufacture, model
		- it used to match and load a driver which support this device 
		- kernel search for drivers which supports this device.
		
- Rule of device tree:
	- define machine
	- pass botargs to the kernel
	- populate device 

		##############################################################################################################################################################
		################################################################### Process ##################################################################################
		##############################################################################################################################################################																

Process:
	- from the kernel point of view it is entity which needs resources
	- every process hat it is own stack 

Kernel stack:
	- at the end of the stack there is Thread_info struct 

- mm_struct:
	- it contain all information related to process address space
	- 

- kernel code is executed in 2 possible ways:
	- Process context -> system call
	- interrupt -> hardare or exception
		
		##############################################################################################################################################################
		################################################################### Double Linked List #######################################################################
		##############################################################################################################################################################																

- LIST_HEAD(list_name):
	- macro declare list_name of type list_head

- list_entry(p,t,m):
	- Returns the address of the data structure of type t in which the list_head field that has the name m and the address p is included.


		##############################################################################################################################################################
		################################################################### Wait_queue ###############################################################################
		##############################################################################################################################################################

- wait_queue_head_t:
	struct __wait_queue_head {
		spinlock_t lock;
		struct list_head task_list;};
	typedef struct __wait_queue_head wait_queue_head_t;

- wait_queue_t:
	struct __wait_queue {
		unsigned int flags;
		struct task_struct *task;
		wait_queue_func_t func;
		struct list_head task_list;};	
	typedef struct __wait_queue wait_queue_t;

- DEFINE_WAIT(wait):
	- declare a new wait_queue_t variable and initializes it with the descriptor of the process currently executing on the CPU

- tasklets and softirq:
	- execute by work queue

- softirq:
	- statically allocated
	- can run concurrently
	
- tasklets:
	- dynamically allocated
	- serialized
	-
	
		##############################################################################################################################################################
		################################################################### Hardware Context #########################################################################
		##############################################################################################################################################################

- hardware context:
	- set of data needed to be loaded im register for process to be executed
	- it is stord in process descriptor and in the kernel stack

- TSS:
	- task state segment 
	- it has kernel mode stack and privilige
	- 

- interrupt:
	- it can come anytime
	- interrupt handler should never sleep because scheudler is deacitvated
	- PIC stores a vector to allow the cpu to find out which interrupt line was active
	- Interrupt Descriptor Table (IDT) map each interrupt with a handler it has maxium 256 interrupt
	- interrupt handler should never sleep because all data need to restore the execute is stored in Kernel stack which is related to the running process
	- when interrupt happens the kernel will save all the registers of the current process and then call do_IRQ() which call all ISR
	- kernel core will handle the interrupt not the code the user write

- request_irq:
	- will add interrupt handler to the list which the core kernel will call to excute the interrupt
	-
- interrupt handler:
	- dont block 
	- dont call anything which might call schedule
	- dont call copy_to_user() as it might lead to fault 
	
	
- IRQ sharing:
	- iterrupt handler execute several ISR every ISR should decide if the interrupt is relevant or not

kernel control path:
	- denotes the sequence of instructions executed by the kernel to handle a system call
	- each kernel control path refers to its own private kernel stack
	
	##############################################################################################################################################################
	################################################################### timing ###################################################################################	
	##############################################################################################################################################################
RTC:
	- it ticks also when the PC is off 
	- it has memory to store time

TSC:
	- time stamp counter 
	- processor has a specific pin which connected to oscillator 
	- a specific register will be increased by each tick
	- the counter is an equation in frequency of the signal
	
PIT:
	Programmabler Interval timer issue interrupt at a speific rate

Time related activity:
	- update time elasped, update time, scheudle
	
jiffies:
	- it stores the number of elapsed ticks since the system was started
	- it is initialized by -5 minutes so if the kernel has a mistake with handling overflow it would cause a problem after 5 minutes
	
timer:
	- gurantee that aspecific task is executed after at least a specific time
	- 
Dynamic Timers:
	- it is stord in timer_list
	

	##############################################################################################################################################################
	################################################################### VFS ######################################################################################	
	##############################################################################################################################################################

superblock:
	- store information about the whole file system, 
	
inode:
	- store information about a speific file
	
file object:
	- store information about the interaction between a proccess and an open file
	- there will be file object for every open call system
dentry:
	- store information about the linking of a directory
	
file system: 
	- the idea is to put a function to support a lot if file system and replace this function according to the file system type

Sysfs:
	- user space manifestation of kernel device model
	
Bus_register:
	- create /sys/bus/
	
device_register:
	- /sys/device/
	
		##############################################################################################################################################################
		################################################################### Kbuild ###################################################################################	
		##############################################################################################################################################################

kbuild:
	- it ties the configration and the build prcoess 
	- config_FOO: 
		- FOO -> y - yes build it to the kernel
			  -> m - module build as a seperate object
			  -> n - no donot build it
	
	- kconfig:
		- where CONFIG_FOO is defined
		
	- makefile:
		- normal make file
		
	- .config:
		- where the kernel configuration is stored

- Kernel configuration file:
	- as a start there is a configuration file for each platorm under arch/<arch>/configs/platform_defconfig
	- copy the file in root folder with name .config
	
- in tree module:
	- internal to linux kernel tree
	
- out of tree:
	- external to linux
	- kernel will issue message when u insert it 
	
- u always need a precompiled version of the linux to build a gainst it

- make - C <path to linux kernel tree> M= <path to ur module> [target]
	- in tree path is: /lib/modules/$(uname -r)/build 
	- out of tree is
		-C source/linux 
		ARCH=arm
		CROSS_COMPILE=toolchain
	
target:
	- modules: to build a module
	
- obj-<x> := module_name.obj
	- m : it is build as dynamically module
	- y : it is build as statically module
	
		##############################################################################################################################################################
		###################################################################   LKM  ###################################################################################	
		##############################################################################################################################################################			  

- toolchain:
	- the task of toolchain is to compile the code, generate instruction which suitable for CPU, it should support the language
	- compile linker and assembler
	- c library
	- it cinsists of:
		- Binutils: linker and assembler
		- Compiler: GCC
		- C library: interface to OS
		- linux header: 
		
	- u should add the path of the toolchain to 
	
- souce code: 
	- it is linux code + Arch-specific code
	
LKM:
	- enables to change the kernel without rebuilding it every time
	- module should return 0 in success
	- ERR_PTR(-ENOM) -> change the error to address
	- __init/exit -> memory optimiziazion, memory will be freed after the function is called
	- printk() -> it output to kernel logfile -> dmesg will show it it is in RAM
	- lsmod -> show all the modules which are in memory
	- linux log file is an array which has size defined in the compilation process through an micro
	- to write to the kernel buffer from user space u can always use echo " test" /dev/kmsg

- printk():
	- it will put message in buffer
	- printk(KERN_WARNNING "hello world \n");

- module_init:
	- it should return integer
	- it is called during boot time in static and during insertion if it is dynamically build
	- it is good to make it static 
	
- module clean_up:
	- return integer
	- it is only useful when u build dynamically module
	- it should undo what u have done in module init function
	
- __init / __exit:
		- it macro which is compiler attribute 
		- it tells the compiler to set this code in a specific section which make it easier to delete the data after the initialized
		- it makes sense only in static modules 
		_ __exit -> it would be excluded if the module is statically build as u cannot remove the module

module_init():
		- macro which will register the function as module enty point the same as module_exit()
		
make file:
	- when u write make in shell it will search for a file which has the name makefile
	- make file has the following structure 
		target : denpendent
			rule
			
	obj-m += file.o
		- create the file which name is file.o using file.c 
		- add the name in list oject list
		
device driver:
	- block -> it can be mounted Hard driver and has buffer
	- char -> SPI, I2C
	- each device driver should register itself using driver_register()
	- it should expose interface to user space application
	- 

dev_t:
	- it represent major and minor number where major represent a class of devices or drivers for example a hard disk while the minor can 
		represent a parition inside that class
	- major is 12 bits size while the minor is 20 bits
	- major tells linux which driver to use while minor is handled inside the driver itself
	
LDM:
	- linux device model divide the drivers into bus, device, device drives
	- every device might it on a bus
	- driver shall register it to kernel frame work and to a bus
	- when the driver register itself a file under /dev/-- will be created
	
Proc filesystem:
	- it is a way to look inside the kernel to get information about the processes, kernel, etc
	- proc file system is in RAM

sysfs:
	- u can see the device model from different points of view (bus support, class view or device )
				
- foreach bus there is a bus core driver, 
	bus is a channel between processor and device,
	bus core driver should allocate bus_type structure and register itself using "bus_register()"w ith kernel list of bus_type
	when u call device_register a list of supported deivce from the bus is updated,
	when u call driver_register a list of drivers which can handle a certain device is registered.
					
##############################################################################################################################################################		
file descriptor:
	- it represent interaction between process and an opened file.
	- if in the same process the file is opened many times, we will get a a different file descriptor but the same file object
	- if serveral process openened the file then we will get a different file object and a different file descriptor
	
process descriptor:
	- it has PC, SP, general proccess registes
	- when the kernel decides to resume the work it will reload the registers from proccess descriptor
	- 

zombie process:
	- process which it is parent exit without calling wait
	- the kernel reparenting the kernel to init process which will call wait() periodically
	- to insert the module use -> insmod path_of_the_module
	
soft link:
	- ln -s file link
	
- to know linux kernel:
	- uname -r ->
		
building Linux kernel:
	- obtain source file
	- extract source file in a folder
	- configure using menuconfig
	- build kernel
	
- top-level makefile:
	- make file at the top of the source code
	- it has the version of linux in it
	
<<<<<<< HEAD
- debug message
	#define pr_fmt(fmt) "%S : " fmt, __FUNC__
	#define pr_info(fmt,---) printk(pr_fmt(fmt), ##__VAR_ARGS__)

- #define container_of(ptr, type, member) \
	 ( (type * ) ( (char*)ptr - (char *)&(((type*)0)->member ) ) ) 

			##############################################################################################################################################################
			################################################################### Schulung #################################################################################	
			##############################################################################################################################################################

- c language:
	- it can access memory range while python needs operating system to communicate with.
	- it gives portabitily becuase it is not architecture dependent.
	- u choice which c version depends on the compiler.
	- ansci c is c89

- compilation processing:
	file.c -> | prepossing | -> file.i -> | compiler | -> file.s -> | assembler | -> file.o -> | linker | -> file.exe 

- library:
	- it is exectuable without main
	
- .elf -> it is the output for linux
- .bin -> normal exectuable
- .hex -> it is .bin but changed as hex

- minGW:
	-> native toolchain
	
- eclipse:
	-> it is Idee 
	
- DataTypes:
	- integer:
		- char: . size byte 
				 . -128 : 127
		
		- unsigned: 255 = 2^8 - 1
	
	integer:
		- most of the time it is 4 bytes
		
	
- implicit casting:
	- int and float would map to float
	- it happens automatically
	
- explicit:
	- u should do it ur self

- fflush(stdout) -> send eveything to the output

- to set a specific bit :
	- R |= (1 << n)
	
- to reset a bit:
	- R &= ~(1 << n);
	
- to toggle a bit:
	- R ^= ~(1 << n);

- steps to set enviromental to compile C code:
	- install GNU tool chain
	-

- map file:
	- it contains symbol table

- micro processor: CPU
	- IC which perform logical operations (ALU, CU, Registers) + I/O 

micro Controller:
	- CPU + RAM + perpherials

- 2D array:
	- int x[2][4] = {{},{}}; -> the first number is the number of Raws
	
- %s:
	- it will print until it meets "/0"
	
- strcpy:
	- strcpy(a, b) -> copy a to b
	
- Local Variables:
	- it has garbage as initialize value
	
- Static global:
	- it makes the Variable local to this file and initialize value is zero
	
- extern:
	- it is created in a file but it can be used in different file 
	- some compiler put extern by default
	
- struct :
	- defination of structure does not occupy any memory.
	- once u use it u occupy data in memory
	- if u initialize any member of structure the rest will be zeros
	- try always to pass struct by reference
	
- MACRO:
	- #x -> 'x'
	- x##y -> xy
	- (...) -> __VAR_ARGS__

- FPU:
	- floating point unit
	- math on float numbers
	
- Memory:
	- RAM:
		- Random access memory, R/W, volatile
		
		- SRAM:
			- 6 Transistors
			- no refresing time is required as it is inverse system
			- faster than DRAM 
			- it is used in Cache
			- it is expensive
		
		- DRAM:
			- it is based on capacitor
			- becuase of leckage, it should recharged 
			- cheaper than SRAM
	
	- ROM:
		- it is not volatile
		- Read only memory
	
		- PROM:
			- it can be written on it only once
			- it is written by user
		
		Masked ROM:
			- by the manufacture 
			- BIOS
			
		EPROM:
			- eraseable ROM
			- 
		
		HYBRID:
			- R/W nonvolatible
			
			EEPROM:
				- Ersable electrically
				
- ISR:
	- in flash would be a assmeble to branch to a specific function with a specific name 

- ARM M:
	- it is more than only processor. it is processor + NVIC + flash + systick 

- Non-Vectored:
	- CPU jump to the same interrupt handler
	- there it would be decided where to go after it

- Vector:
	- every interrupt has it is own address to jump to

- interrupt latency:
	- time between start of signal till interrupt starts

- GPIO:
	- O/P
		- open drain:
			- u use only 1 transistor
			- u can only aborb current
			- it is called high impedenze
			- micro controller is not the current supplier

		- push pull: 
			- you use 2 transistor to achieve it 
			- u achieve 0 and 1 on the pin
			
- Vdd / Vcc: 
	- postive
	
- Vss / Vee :
	- negative
	
- AMR:  power supply / maxium current / pin voltage
	- V (output high) should be more than V (input high)
	- V (output low) should be less than V (input low)

				####################################################################################################################################
				##################################################################### UART #########################################################
				####################################################################################################################################	
	
- simplex:
	- one way all the time
	
- half duplex:
	- one way at the same time
	
- full duplex:
	- two way at the same time
	
- synchronouis:
	- sending and receiving happens according with the clock edge

- asynchronouis:
	- sending and receiving depends on baudrate and frame 
	- no clock is needed to achieve sending and receiving data
	
- UART:
	- full duplex
	- asynchronouis which means no clock
	- peer to peer communication

- Drivers:
	- write base address
	- define structure of registes of UART
	- type casting base address of uart
	- define interrupt line
	- define marco to enable uart and interrupt
	
				####################################################################################################################################
				##################################################################### SPI  #########################################################
				####################################################################################################################################	
	
- SPI: 51
	- synchronouis
	- full duplex
	- single master multi slave-
	- SPI has very high out through
	- small distance because it is frameless no CRC
	- it is only shift register that is why it is really fast
	- too many pins
	- wiring:
		- SCLK: clock
		- MOSI: Master output slave input
		- MISO: Master input slave output
		- SS1,2: 	Slave select
		
				#############################################################################################################################
				####################################################################  Timers  ###############################################
				#############################################################################################################################

- timer is a couner, it has clock as input 
- Time Delay = prescale * couner value / frequency
- Timer can generate peodic event 



				