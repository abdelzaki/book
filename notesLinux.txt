Asemble:
	- "call" function in Asemble : put the next address(address after the function call ) to the the stack and move to the function which should be called.
	- %eax -> it means register 
	- compiler decide which data goes to register or to stack.
	- Register -> compiler,  Cache -> HW decided,  Memory -> operationg system,  Storage -> operating system

Dual-Mode:
	- there is a bit in in the processor (HW) which we can set/reset it to switch between User / kernel Mode
	- instruction change the mode to kernel and another to change to user mode
	
System call: 
	- should be supported by the hardware
	- save numbe of system call in register
	- call int with the number of the system call to excute system call
	
interrupt:
	- Hardware moves to Kernel stack
	- if system call inside the kernel stack, the Stack would grow no new stack should be created

Ring buffer:
	- modula arithmetic
	 
Microkernel: 
	- multiable proccess to excute the code
	
monolithic:
	- the kernel is one proccess
	
kernel address:
	- 32 bits is always 4 GBs
	- kernel is always the first 1 GB of the RAM
	
scheudler:
	- maxium CPU utilization
	- first come first service Process policy
	- burst time -> how long the process will excute untill it blocks
	- Round Robin :
		- quantum -> how long is process is allowed to run 
		- if quantum is infinity then we have first run first service
		- if quantum is zero not then we wont excute any thing 
		- 
NAND:
	- allow random access
	- write -> can only change 1 to 0
	- to change the bit to one u have to erase block 
	- the SSD has flash translation layer(FTL) which achieve wear leaving
	- it has OOB (out of band) area to store error detection 
	

NOR:
	- code can be excuted from it
	- it is expensive

malloc:
	- sbrk -> to create heap page
	- malloc is implemenit in library not in the kernel
	- 	
stack:
	- in linux stack is expandable

heap:
	-  	
JFFS2:
	- it applied 3 lists empty, full, dirty -> to avoid copy and paste data which not needed to copy
	
Files:
	- file is a string of bytes
	
inode:
	- it identify a file, it has alot of data about the file 
	- 

task_struct:
	- it represents a process
	- 
	
pid:
	- it identify a process
	- 

##############################################################################################################################################################
################################################################ Embedded Linux ##############################################################################	
##############################################################################################################################################################

Components:
	- Toolchain -> to compile linux
	- Bootloader -> the program which will load the kernel to memory
	- Kernel -> it manages the resources
	- Root file system -> contains what the linux will run when it started to run
	

Toolchain:
	- set of tools that compilesource code into executable
	- Components are : compiler, linker, run time libraries

##############################################################################################################################################################
##################################################################     I/O      ##############################################################################	
##############################################################################################################################################################

- all memeory access should be through mmu unit
- I/O is mapped in two ways:
	- regoin in process is reserved fpr mapping the I/O called "memeory mapped IO MMIO"
	- using a special instruction to access the I/O called "port mapped IO" PIO
	
- u need to ask the permission from the OS to get access the memory region u want to access

- ioremap:
	- map the address to a process address space 
	- it is ARCH specific header
	- it takes physical address as a parameter
	- __iomem -> compiler attribute to tell it is a IO 
	
- in order to work on IO memoy region two steps are required
	-> ask permission "requestrequest_mem_region"
	-> map the IO to VAS "ioremap"
	-> write to it through using specifi API "ioread, iowrite"

- the another way is accessing the port by a special instructions:
	- inb,outb
	
##############################################################################################################################################################
##################################################################      I2C     ##############################################################################	
##############################################################################################################################################################

- every device should have address
- it is 2 line communications
- the line has 7 bits address
- master talks to 1 address at a time
- driver is rep



##############################################################################################################################################################
################################################################### Boot process #############################################################################	
##############################################################################################################################################################

- Bootloader:
	- initializes memeory
	- load kernel to RAM and create excutation enviroment
	- bootloader should pass data structure which descripe HW and pass pointer to kernel command line
	

1th Stage:
	- Rom code load secondary program loader (SPL) from Flash / USB / internet to SRAM

2th Stage:
	- load Uboot from flash / USB /internet to DRAM
	
U-boot:
	- bootm address_of_kernel address_of_ramdisk address_of_dtb
	- pass memory address of kernel and device tree
	- kernel will start and will call init process -> busybox init or systemV or system D

Image:
	- is vmlinux converted as binary format
	
zImage:
	- compressed Image 

uImage:
	- zImage + 64-byte U-Boot header

bootargs:
	- is a way to send data to the kernel 

	
##############################################################################################################################################################
################################################################### RFS #############################################################################	
##############################################################################################################################################################	

initramfs:
	- also known as Ramdisks 
	- file system image which is in RAM by bootloader
	- it is compressed cpio which is a compressed archive 
	- 
	
Disk image:
	- copy of Root file system which is ready to be copied in mass stotage device 
	

##############################################################################################################################################################
################################################################### Init Process #############################################################################	
##############################################################################################################################################################	

/etc/inittab: 
	- Configuration file to decide where to find the init process
	- ::sysinit:/etc/init,d/rcS -> where to run the first script
	- ::rspawn:/sbin/syslogd -n -> keep it running


##############################################################################################################################################################
################################################################### Memory ###################################################################################	
##############################################################################################################################################################

Logical address:
	- memory inside the process.
	- it is divided to page and offset inside the page
	
Linear address / Virtual address :
	- 4 GB Ram address 0X00000000 -> 0XFFFFFFFF
	- the address after MMU calculation

---> Page frame in Linux is 2^12 = 4096 = 4 KB


physical address:
	- memory cell in memory chips
	
Kernel memeory address:
	- 896 MB is the kernel
	- 128 MB is high memory mapping
	- at the end we get 1 GB kernel 
	
MMU:
	- Logical address -> /Segemenataion Unit/ -> Linear address -> /Paging unit/ -> physical address 	
	
Layout of Memory:
	- kernel doesnot start from 0X0 address because that is stored for BIOS routine in Laptop 

mem_map:
	- array of page descriptors of type page
	- the last 128 MB of high memory is mapped tp high-memory page frame

RAM: memory address
	- starts from 0X00100000--0
	- 

IO Ports:
	- mapped to another Memory address
	- it uses another bus rather than the memory address
	- it is mapped to RAM to make it easier to generate address
	

---> kernel must keep tack of the status of each page frame

page:
	- it is page descriptor
	- stored in mem_map array
	-  memory is split in Page frame

Block:
	- process is split in blocks

process page table:
	- every process has this table
	- it is stored in the kernel space
	- it map block to page frame
	
page table:
	- it could be 2 level dir,table,offst so we dont need to have contigues memory 

process:
	- it is a program in excutation
	- every process has PCB (process control block)
	- kernel stack for the process -> it is used to store the context of the process when system call happens
	- page table which map physical memory to virtual memory

page allocar:
	- array of double linked list which points to a free page frame with size which is 2^order of the array
	

buddy_allocator:
	- Bit map + buudy allocator
	
	
slap allocator:
	- it depend on the idea that the kernel uses often  the same area object 
	- allocate a according to a specific object
	
process get new memory:
	- new process is created
	- process keeps growing until the stack is not enough
	- malloc 

VAS: 
	- virtual address space
	- divivded to homogenous segement -> text, data, OSS , stack, heap, library
	- thread share every thing in the VAS except stack
	- 

Thread:
	- kernel schedulable entity (KSE)
	- every thread maps to structure task_structure
	- every thread has user stack and kernel stack
	- kernel stack are fixed in size 2 pages
	- 





---> procces descriptor has a field which points to the address space of the process(memory descriptor)


##############################################################################################################################################################
###################################################################   MTD   ##################################################################################	
##############################################################################################################################################################

MTD:
	- memory technology device
	- it can handle NOR and NAND
	- the kernek knows abouth the partition through Device tree or Board support package
	- MTD with major number 90 to handle char /dev/mtd0 or /dev/mtd2 read and write 
	- mtd with major number 31 to handle block deice /dev/mtdblock0 /dev/mtdblock1
	- flash should always be erase before writting in it
	- static struct mtd_partition mlc3250_nand_partition[] = { -> it is the way to partition Nand device

	
##############################################################################################################################################################
################################################################### Char Driver ##############################################################################	
##############################################################################################################################################################	

- char device exposed functions and data to user space via /dev

- char dev is represented using the followin data structure
	struct cdev{kobject, owner, file_operation, dev_t-> major / minor }

- to create a char device u need to regiser it 
	-> register_chrdev_region -> if u know in advance the dev_t. it will occupy the driver number
	-> alloc_chrdev_region -> to allocate device and let the kernel decide which number will be given to the char driver, it will create 
		deivce under /proc/devices
	-> create class under /sys/class/
	-> create device under /dev -> it represent device not driver as it has minor number and it is created using "mknod" or using device create
	
file_operation:
	-> open bind the inode with filep because all other file operations work on file data structure not on inode data structure
	
		
################################################################################################################################################
################################################################### Platform_driver ############################################################	
################################################################################################################################################

- it represents a driver and device which is not a part of the conventioal drivers such as I2C, SPI, 

- in order to handle plat_form u need to register the drivers which is a data strucure which contains name, probe, remove

- probe is called when matches happen between plat_form device and plat_form drivers

- to represent a plat_form_driver the following data structure should be used "struct platform_driver ":
static struct platform_driver mypdrv = {
	.probe = my_pdrv_probe,
	.remove = my_pdrv_remove,
	.driver = {
		.name = "my_platform_driver",
		.owner = THIS_MODULE,},};
		
- platform_device is represented using platform_device struct:
	struct platform_device {
		const char *name;
		u32 id;
		struct device dev;
		u32 num_resources;
		struct resource *resource;
		};
		
- platform_driver regiser itself to platfrom_bus using platform_driver_register()
		
- resource is what represent the device from the hardware point of view "IO, Memory, IRQ"
	resource{start, stop, name, flag}
		
- 
	
################################################################################################################################################
################################################################### Device tree ############################################################	
################################################################################################################################################	

- device tree: 
	- is enabled by setting CONFIG_OF to y 
	- collection of device node 
	- it should have a root node
	
- node:
	- it express itself using properities
	- any node can have subnode 
	
- DTS -> it is the source file text file

- DTB -> the compiled source

- dtsi -> header file which represent the SOC level 

- reference:
	- & is used to reference a node in device tree
	
- #size-cells:
	- how many 32-bits represent the size-cells

- #address-cells:
	- how many 32-bits represent address
	
- Properities:
	- it is a key value pair 
	- it is standard names and there is standard to use non standard name (custom proerities)
	- compatible:
		- it is a string list
		- client programm "linux" it is list from the most specific to the most general
		- it is used for driver selections 
		- manufacture, model
		- it used to match and load a driver which support this device 
		- kernel search for drivers which supports this device.
		
- Rule of device tree:
	- define machine
	- pass botargs to the kernel
	- populate device 

##############################################################################################################################################################
################################################################### Process ##################################################################################	
##############################################################################################################################################################																

Process:
	- from the kernel point of view it is entity which needs resources
	- every process hat it is own stack 

Kernel stack:
	- at the end of the stack there is Thread_info struct 

mm_struct:
	- it contain all information related to process address space
	- 

- kernel code is executed in 2 possible ways:
	- Process context -> system call
	- interrupt -> hardare or exception
		
##############################################################################################################################################################
################################################################### Double Linked List #######################################################################	
##############################################################################################################################################################																

LIST_HEAD(list_name):
	- macro declare list_name of type list_head

list_entry(p,t,m):
	- Returns the address of the data structure of type t in which the list_head field that has the name m and the address p is included.


##############################################################################################################################################################
################################################################### Wait_queue ###############################################################################	
##############################################################################################################################################################

wait_queue_head_t:
	struct __wait_queue_head {
		spinlock_t lock;
		struct list_head task_list;};
	typedef struct __wait_queue_head wait_queue_head_t;

wait_queue_t:
	struct __wait_queue {
		unsigned int flags;
		struct task_struct *task;
		wait_queue_func_t func;
		struct list_head task_list;};	
	typedef struct __wait_queue wait_queue_t;

DEFINE_WAIT(wait):
	- declare a new wait_queue_t variable and initializes it with the descriptor of the process currently executing on the CPU

tasklets and softirq:
	- execute by work queue

softirq:
	- statically allocated
	- can run concurrently
	
	
tasklets:
	- dynamically allocated
	- serialized
	-
	
##############################################################################################################################################################
################################################################### Hardware Context #########################################################################	
##############################################################################################################################################################

hardware context:
	- set of data needed to be loaded im register for process to be executed
	- it is stord in process descriptor and in the kernel stack

TSS:
	- task state segment 
	- it has kernel mode stack and privilige
	- 

interrupt:
	- it can come anytime
	- interrupt handler should never sleep because scheudler is deacitvated
	- PIC stores a vector to allow the cpu to find out which interrupt line was active
	- Interrupt Descriptor Table (IDT) map each interrupt with a handler it has maxium 256 interrupt
	- interrupt handler should never sleep because all data need to restore the execute is stored in Kernel stack which is related to the running process
	- when interrupt happens the kernel will save all the registers of the current process and then call do_IRQ() which call all ISR
	- kernel core will handle the interrupt not the code the user write

- request_irq:
	- will add interrupt handler to the list which the core kernel will call to excute the interrupt
	-
interrupt handler:
	- dont block 
	- dont call anything which might call schedule
	- dont call copy_to_user() as it might lead to fault 
	
	
IRQ sharing:
	- iterrupt handler execute several ISR every ISR should decide if the interrupt is relevant or not

kernel control path:
	- denotes the sequence of instructions executed by the kernel to handle a system call
	- each kernel control path refers to its own private kernel stack
	
##############################################################################################################################################################
################################################################### timing ###################################################################################	
##############################################################################################################################################################

RTC:
	- it ticks also when the PC is off 
	- it has memory to store time

TSC:
	- time stamp counter 
	- processor has a specific pin which connected to oscillator 
	- a specific register will be increased by each tick
	- the counter is an equation in frequency of the signal
	
PIT:
	Programmabler Interval timer issue interrupt at a speific rate

Time related activity:
	- update time elasped, update time, scheudle
	
jiffies:
	- it stores the number of elapsed ticks since the system was started
	- it is initialized by -5 minutes so if the kernel has a mistake with handling overflow it would cause a problem after 5 minutes
	
timer:
	- gurantee that aspecific task is executed after at least a specific time
	- 
Dynamic Timers:
	- it is stord in timer_list
	

##############################################################################################################################################################
################################################################### VFS ######################################################################################	
##############################################################################################################################################################

superblock:
	- store information about the whole file system, 
	
inode:
	- store information about a speific file
	
file object:
	- store information about the interaction between a proccess and an open file

dentry:
	- store information about the linking of a directory
	
file system: 
	- the idea is to put a function to support a lot if file system and replace this function according to the file system type

Sysfs:
	- user space manifestation of kernel device model
	
Bus_register:
	- create /sys/bus/
	
device_register:
	- /sys/device/
	
##############################################################################################################################################################
################################################################### Kbuild ###################################################################################	
##############################################################################################################################################################

kbuild:
	- it ties the configration and the build prcoess 
	- config_FOO: 
		- FOO -> y - yes build it to the kernel
			  -> m - module build as a seperate object
			  -> n - no donot build it
	
	- kconfig:
		- where CONFIG_FOO is defined
		
	- makefile:
		- normal make file
		
	- .config:
		- where the kernel configuration is stored

- Kernel configuration file:
	- as a start there is a configuration file for each platorm under arch/<arch>/configs/platform_defconfig
	- copy the file in root folder with name .config
	
	
##############################################################################################################################################################
###################################################################   LKM  ###################################################################################	
##############################################################################################################################################################			  

- toolchain:
	- the task of toolchain is to compile the code, generate instruction which suitable for CPU, it should support the language
	- compile linker and assembler
	- c library
	- it cinsists of:
		- Binutils: linker and assembler
		- Compiler: GCC
		- C library: interface to OS
		- linux header: 
		
	- u should add the path of the toolchain to 
	
- souce code: 
	- it is linux code + Arch-specific code
	
LKM:
	- enables to change the kernel without rebuilding it every time
	- module should return 0 in success
	- ERR_PTR(-ENOM) -> chnange the error to address
	- __init/exit -> memory optimiziazion, memory will be freed after the function is called
	- printk() -> it output to kernel logfile -> dmesg will show it it is in RAM
	- lsmod -> show all the modules which are in memory
	- linux log file is an array which has size defined in the compilation process through an micro
	- to write to the kernel buffer from user space u can always use echo " test" /dev/kmsg
	
make file:
	- when u write make in shell it will search for a file which has the name makefile
	- make file has the following structure 
		target : denpendent
			rule
			
	obj-m += file.o
		- create the file which name is file.o using file.c 
		- add the name in list oject list
		
device driver:
	- block -> it can be mounted Hard driver and has buffer
	- char -> SPI, I2C
	- each device driver should register itself using driver_register()
	- 

dev_t:
	- it represent major and minor number where major represent a class of devices or drivers for example a hard disk while the minor can 
		represent a parition inside that class
	- major is 12 bits size while the minor is 20 bits
	- major tells linux which driver to use while minor is handled inside the driver itself
	
LDM:
	- linux device model divide the drivers into bus, device, device drives
	- every device might it on a bus
	- driver shall register it to kernel frame work and to a bus
	- when the driver register itself a file under /dev/-- will be created
	
Proc filesystem:
	- it is a way to look inside the kernel to get information about the processes, kernel, etc
	- proc file system is in RAM

sysfs:
	- u can see the device model from different points of view (bus support, class view or device )
				
- foreach bus there is a bus core driver, 
	bus is a channel between processor and device,
	bus core driver should allocate bus_type structure and register itself using "bus_register()"w ith kernel list of bus_type
	when u call device_register a list of supported deivce from the bus is updated,
	when u call driver_register a list of drivers which can handle a certain device is registered.
					
##############################################################################################################################################################
		
file descriptor:
	- it represent interaction between process and an opened file.
	- if in the same process the file is opened many times, we will get a a different file descriptor but the same file object
	- if serveral process openened the file then we will get a different file object and a different file descriptor
	- 
	
process descriptor:
	- it has PC, SP, general proccess registes
	- when the kernel decides to resume the work it will reload the registers from proccess descriptor
	- 

zombie process:
	- process which it is parent exit without calling wait
	- the kernel reparenting the kernel to init process which will call wait() periodically
	- to insert the module use -> insmod path_of_the_module
	
soft link:
	- ln -s file link
	
- to know linux kernel:
	- uname -r ->
		
building Linux kernel:
	- obtain source file
	- extract source file in a folder
	- configure using menuconfig
	- buld kernel
	
- top-level makefile:
	- make file at the top of the source code
	- it has the version of linux in it
	
##############################################################################################################################################################
################################################################### Schulung #################################################################################	
##############################################################################################################################################################

- c language:
	- it can access memory range while python needs operating system to communicate with.
	- it gives portabitily becuase it is not architecture dependent.
	- u choice which c version depends on the compiler.
	- ansci c is c89

- compilation processing:
	file.c -> | prepossing | -> file.i -> | compiler | -> file.s -> | assembler | -> file.o -> | linker | -> file.exe 

- library:
	- it is exectuable without main
	
- .elf -> it is the output for linux
- .bin -> normal exectuable
- .hex -> it is .bin but changed as hex

- minGW:
	-> native toolchain
	
- eclipse:
	-> it is Idee 
	
- DataTypes:
	- integer:
		- char: . size byte 
				 . -128 : 127
		
		- unsigned: 255 = 2^8 - 1
	
	integer:
		- most of the time it is 4 bytes
		
	
- implicit casting:
	- int and float would map to float
	- it happens automatically
	
- explicit:
	- u should do it ur self

- fflush(stdout) -> send eveything to the output

- to set a specific bit :
	- R |= (1 << n)
	
- to reset a bit:
	- R &= ~(1 << n);
	
- to toggle a bit:
	- R ^= ~(1 << n);

- steps to set enviromental to compile C code:
	- install GNU tool chain
	-

- map file:
	- it contains symbol table

- micro processor: CPU
	- IC which perform logical operations (ALU, CU, Registers) + I/O 

micro Controller:
	- CPU + RAM + perpherials