Asemble:
	- "call" function in Asemble : put the next address(address after the function call ) to the the stack and move to the function which should be called.
	- %eax -> it means register 
	- compiler decide which data goes to register or to stack.
	- Register -> compiler,  Cache -> HW decided,  Memory -> operationg system,  Storage -> operating system

Dual-Mode:
	- there is a bit in in the processor (HW) which we can set/reset it to switch between User / kernel Mode
	- instruction change the mode to kernel and another to change to user mode
	
System call: 
	- should be supported by the hardware
	- save numbe of system call in register
	- call int with the number of the system call to excute system call
	
interrupt:
	- Hardware moves to Kernel stack
	- if system call inside the kernel stack, the Stack would grow no new stack should be created

Ring buffer:
	- modula arithmetic
	 
Microkernel: 
	- multiable proccess to excute the code
	
monolithic:
	- the kernel is one proccess
	
kernel address:
	- 32 bits is always 4 GBs
	- kernel is always the first 1 GB of the RAM
	
scheudler:
	- maxium CPU utilization
	- first come first service Process policy
	- burst time -> how long the process will excute untill it blocks
	- Round Robin :
		- quantum -> how long is process is allowed to run 
		- if quantum is infinity then we have first run first service
		- if quantum is zero not then we wont excute any thing 
		- 
NAND:
	- allow random access
	- write -> can only change 1 to 0
	- to change the bit to one u have to erase block 
	- the SSD has flash translation layer(FTL) which achieve wear leaving
	- it has OOB (out of band) area to store error detection 
	

NOR:
	- code can be excuted from it
	- it is expensive



	
malloc:
	- sbrk -> to create heap page
	- malloc is implemenit in library not in the kernel
	- 
	
stack:
	- in linux stack is expandable

heap:
	-  
	
JFFS2:
	- it applied 3 lists empty, full, dirty -> to avoid copy and paste data which not needed to copy
	
Files:
	- file is a string of bytes
	
inode:
	- it identify a file, it has alot of data about the file 
	- 

task_struct:
	- it represents a process
	- 
	
pid:
	- it identify a process
	- 

##############################################################################################################################################################
################################################################ Embedded Linux ##############################################################################	
##############################################################################################################################################################

Components:
	- Toolchain -> to compile linux
	- Bootloader -> the program which will load the kernel to memory
	- Kernel -> it manages the resources
	- Root file system -> contains what the linux will run when it started to run
	

Toolchain:
	- set of tools that compilesource code into executable
	- Components are : compiler, linker, run time libraries


##############################################################################################################################################################
################################################################### Boot process #############################################################################	
##############################################################################################################################################################

1th Stage:
	- Rom code load secondary program loader (SPL) from Flash / USB / internet to SRAM

2th Stage:
	- load Uboot from flash / USB /internet to DRAM
	
U-boot:
	- bootm address_of_kernel address_of_ramdisk address_of_dtb

Image:
	- is vmlinux converted as binary format
	
zImage:
	- compressed Image 

uImage:
	- zImage + 64-byte U-Boot header

bootargs:
	- is a way to send data to the kernel 
	
	
##############################################################################################################################################################
################################################################### RFS #############################################################################	
##############################################################################################################################################################	

initramfs:
	- also known as Ramdisks 
	- file system image which is in RAM by bootloader
	- it is compressed cpio which is a compressed archive 
	- 
	
Disk image:
	- copy of Root file system which is ready to be copied in mass stotage device 
	

##############################################################################################################################################################
################################################################### Init Process #############################################################################	
##############################################################################################################################################################	

/etc/inittab: 
	- Configuration file to decide where to find the init process
	- ::sysinit:/etc/init,d/rcS -> where to run the first script
	- ::rspawn:/sbin/syslogd -n -> keep it running


##############################################################################################################################################################
################################################################### Memory ###################################################################################	
##############################################################################################################################################################

Logical address:
	- memory inside the process.
	- it is divided to page and offset inside the page
	
Linear address / Virtual address :
	- 4 GB Ram address 0X00000000 -> 0XFFFFFFFF
	- the address after MMU calculation

---> Page frame in Linux is 2^12 = 4096 = 4 KB


physical address:
	- memory cell in memory chips
	
Kernel memeory address:
	- 896 MB is the kernel
	- 128 MB is high memory mapping
	- at the end we get 1 GB kernel 
	
MMU:
	- Logical address -> /Segemenataion Unit/ -> Linear address -> /Paging unit/ -> physical address 	
	
Layout of Memory:
	- kernel doesnot start from 0X0 address because that is stored for BIOS routine in Laptop 

mem_map:
	- array of page descriptors of type page
	- the last 128 MB of high memory is mapped tp high-memory page frame

RAM: memory address
	- starts from 0X00100000--0
	- 

IO Ports:
	- mapped to another Memory address
	- it uses another bus rather than the memory address
	- it is mapped to RAM to make it easier to generate address
	

---> kernel must keep tack of the status of each page frame

page:
	- it is page descriptor
	- stored in mem_map array
	-  memory is split in Page frame

Block:
	- process is split in blocks

process page table:
	- every process has this table
	- it is stored in the kernel space
	- it map block to page frame
	
page table:
	- it could be 2 level dir,table,offst so we dont need to have contigues memory 

process:
	- it is a program in excutation
	- every process has PCB (process control block)
	- kernel stack for the process -> it is used to store the context of the process when system call happens
	- page table which map physical memory to virtual memory

buddy_allocator:
	- Bit map + buudy allocator
	
	
slap allocator:
	- it depend on the idea that the kernel uses often  the same area object 
	- allocate a according to a specific object
	
process get new memory:
	- new process is created
	- process keeps growing until the stack is not enough
	- malloc 


---> procces descriptor has a field which points to the address space of the process(memory descriptor)


##############################################################################################################################################################
###################################################################   MTD   ##################################################################################	
##############################################################################################################################################################

MTD:
	- memory technology device
	- it can handle NOR and NAND
	- the kernek knows abouth the partition through Device tree or Board support package
	
##############################################################################################################################################################
################################################################### Process ##################################################################################	
##############################################################################################################################################################																

Process:
	- from the kernel point of view it is entity which needs resources
	- every process hat it is own stack 

Kernel stack:
	- at the end of the stack there is Thread_info struct 

mm_struct:
	- it contain all information related to process address space
	- 
	
##############################################################################################################################################################
################################################################### Double Linked List #######################################################################	
##############################################################################################################################################################																

LIST_HEAD(list_name):
	- macro declare list_name of type list_head

list_entry(p,t,m):
	- Returns the address of the data structure of type t in which the list_head field that has the name m and the address p is included.


##############################################################################################################################################################
################################################################### Wait_queue ###############################################################################	
##############################################################################################################################################################

wait_queue_head_t:
	struct __wait_queue_head {
		spinlock_t lock;
		struct list_head task_list;};
	typedef struct __wait_queue_head wait_queue_head_t;

wait_queue_t:
	struct __wait_queue {
		unsigned int flags;
		struct task_struct *task;
		wait_queue_func_t func;
		struct list_head task_list;};	
	typedef struct __wait_queue wait_queue_t;

DEFINE_WAIT(wait):
	- declare a new wait_queue_t variable and initializes it with the descriptor of the process currently executing on the CPU

tasklets and softirq:
	- execute by work queue

softirq:
	- statically allocated
	- can run concurrently
	
	
tasklets:
	- dynamically allocated
	- serialized
	-
	
##############################################################################################################################################################
################################################################### Hardware Context #########################################################################	
##############################################################################################################################################################

hardware context:
	- set of data needed to be loaded im register for process to be executed
	- it is stord in process descriptor and in the kernel stack

TSS:
	- task state segment 
	- it has kernel mode stack and privilige
	- 

interrupt:
	- it can come anytime
	- interrupt handler should never sleep because scheudler is deacitvated
	- PIC stores a vector to allow the cpu to find out which interrupt line was active
	- Interrupt Descriptor Table (IDT) map each interrupt with a handler it has maxium 256 interrupt
	- interrupt handler should never sleep because all data need to restore the execute is stored in Kernel stack which is related to the running process
	- when interrupt happens the kernel will save all the registers of the current process and then call do_IRQ() which call all ISR
	
IRQ sharing:
	- iterrupt handler execute several ISR every ISR should decide if the interrupt is relevant or not

kernel control path:
	- denotes the sequence of instructions executed by the kernel to handle a system call
	- each kernel control path refers to its own private kernel stack
	
##############################################################################################################################################################
################################################################### timing ###################################################################################	
##############################################################################################################################################################

RTC:
	- it ticks also when the PC is off 
	- it has memory to store time

TSC:
	- time stamp counter 
	- processor has a specific pin which connected to oscillator 
	- a specific register will be increased by each tick
	- the counter is an equation in frequency of the signal
	
PIT:
	Programmabler Interval timer issue interrupt at a speific rate

Time related activity:
	- update time elasped, update time, scheudle
	
jiffies:
	- it stores the number of elapsed ticks since the system was started
	- it is initialized by -5 minutes so if the kernel has a mistake with handling overflow it would cause a problem after 5 minutes
	
timer:
	- gurantee that aspecific task is executed after at least a specific time
	- 
Dynamic Timers:
	- it is stord in timer_list
	

##############################################################################################################################################################
################################################################### VFS ######################################################################################	
##############################################################################################################################################################

superblock:
	- store information about the whole file system, 
	
inode:
	- store information about a speific file
	
file object:
	- store information about the interaction between a proccess and an open file

dentry:
	- store information about the linking of a directory
	
file system: 
	- the idea is to put a function to support a lot if file system and replace this function according to the file system type
	
		
##############################################################################################################################################################
		
file descriptor:
	- it represent interaction between process and an opened file.
	- if in the same process the file is opened many times, we will get a a different file descriptor but the same file object
	- if serveral process openened the file then we will get a different file object and a different file descriptor
	- 
	
process descriptor:
	- it has PC, SP, general proccess registes
	- when the kernel decides to resume the work it will reload the registers from proccess descriptor
	- 

zombie process:
	- process which it is parent exit without calling wait
	- the kernel reparenting the kernel to init process which will call wait() periodically
	
	
soft link:
	- ln -s file link
	